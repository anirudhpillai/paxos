\chapter{Conclusion and Evaluation}
% A summary of what the project has achieved. Make sure that you
% address each goal set out in the Introduction chapter, to show that
% you have achieved what you claimed you would. Don’t leave any
% loose ends.
% – A critical evaluation of the results of the project (e.g., how well were
% the goals met, is the application fit for purpose, has good design and
% implementation practice been followed, was the right implementation
% technology chosen and so on).
% – Future work. How could the project be developed if you had another
% 6 months. Take care to differentiate between what you have done
% to satisfy your stated project goals, and work that could be done to
% meet extended goals.

\section{Summary of Achievements}
The project achieved all its goals apart from proving the inductive invariant.
The major deliverables were as follows.
\begin{enumerate}
  \item \textbf{The Adapted Protocol} \\
    We designed the state transition systems for Paxos in order to help encode it in
    Disel. The state transition systems were also tested on the Python simulator
    and then encoded in Disel. We also designed the inductive invariant for Paxos
    that proved its correctness.
  \item \textbf{Client Application} \\
    We also created a client application that uses the encoded protocol. The
    code for the client was extracted using Disel and we successfully wrote
    wrappers around it as well.
\end{enumerate}

\vspace{-5mm}
\section{Critical Evaluation of the project}
Firstly, there were also a few places in the project where things
were not proved mechanically.

\begin{enumerate}
  \item \textbf{Inductive Invariant} \\
    We did not mechanise the proof of the designed inductive invariant in Disel.
    This will enable us to reach the final stage of the previously mentioned Disel workflow,
    thus, strengthening the proof by completely verifying the adapted protocol.
  \item \textbf{Learner in Client Application} \\
    We were successfully able to interface with the extracted code for the client
    application but writing a wrapper around it. The wrapper basically performed
    the role of the learner in Paxos and announced when the acceptors had
    achieved consensus. Using the wrapper meant that client application was not
    fully verified. In order to achieve that, one would have to design and add the
    state transition system for the learner in the adapted protocol and encode it
    in Disel.
\end{enumerate}

We were only able to reach the third stage of the Disel workflow by
verifying the client application and showing that it follows the
adapted protocol and ran out of time to prove the inductive invariant.
While this stage does not show that the protocol itself
is completely verified, we can still think of it as relatively strong
correctness as the protocol is based on the simple Paxos protocol and
we have also designed and come up with a proof for its inductive invariant
as highlighted in the section 4.1.3. Additionally, simple Paxos already has
a proof of correctness provided by Lamport \cite{4}.

Furthermore, Although the learner in the client application was not verified,
writing the
wrapper enabled us to show that it was possible to interface with the code
extracted from Disel. This showed that the verified code generated by Disel
can be used in other larger application as the verified implementation of
a protocol.

The designed adapted protocol and state transition system focused on
the `core' protocol because as previously mentioned, the proof of the `core'
protocol can be used to verify the optimisations. The adapted protocol and
state transition system were tested on the Python simulator and the client
based on it was also verified. Iterating between the proof of the client
and design of the protocol, helped solidify the design and also make it
minimal by removing unnecessary state transitions.

\subsection{Evaluation of Disel}
Disel was the critical component of this project and for most purposes, it
stacked up very well to meet all the requirements.
The experience of encoding in Disel felt very natural. This was because
focusing on the `core' logic of the protocol and then representing it
as state transition diagram is quite intuitive. Which then makes
encoding it as a \texttt{step} function in Disel very easy.

Building the client application showed that one can successfully extract
the OCaml code for the verified protocol. Moreover, writing wrappers
around the code showed that extracted code can be used as a verified library
in other larger applications.

There were numerous instances where, while doing the proofs in Disel
ended up revealing flaws in the implementation. One of these situations was
when we found a mistake in our proposer implementation within
\texttt{send\_accept\_reqs}. Initially, to check
whether we received a promise from every single acceptor, we had the condition,
\texttt{map fst' recv\_promises == acceptors}. The problem with this was that
it required the promises to be received in the same order from the acceptors
with which the acceptors were ordered in the \texttt{acceptors} set. We cannot impose
such ordering on the messages received, so we had to replace the condition
with \texttt{perm\_eq (map fst' recv\_promises) acceptors} that correctly checks
whether a promise had been received from every acceptor by checking that
the set of acceptors who responded (\texttt{map fst' recv\_promises}) is
a valid permutation of the set of acceptors.

Furthermore, we also found a bug in our acceptor implementation. We came
across it when we were not able to prove the post condition of \texttt{acceptor\_round}
as the acceptor was never reaching the \texttt{AAccepted} state.

The reason for this was because we when an acceptor receives an \texttt{accept\_request}
we checked if the incoming proposal had a proposal number greater than the one
currently held by the proposal, and only then move to the AAccepted state. The fact
that we were reading the state of the acceptor after receiving the incoming message
meant that by then the acceptor had already transition its state accordingly
when it received it and so the proposal number held by it was always
equal to the incoming messages proposal. This meant that the acceptor would not
send a promise response.

There were also instances where doing the proofs required the pre
or post conditions of the transition to
be strengthened by case analysing on the the message being sent or received.
One example, in the post condition of \texttt{resp\_to\_prepare\_req}, is as follows. Initially,
the post condition stated that after responding to a \texttt{prepare\_req},
the acceptor would either go the \texttt{APromised} state either holding the
proposal it already had or the new proposal it received. The strengthened
looks at the received message and checks if the incoming proposal has proposal
number greater that the one it has already promised, only then does it transition
to the \texttt{APromised} state holding the new incoming proposal.

\begin{lstlisting}
(* Initial weaker post condition *)
fun (_ : seq nat) m => loc m = st :-> (e, APromised p_current)
    \/ loc m = st :-> (e, APromised p_incoming))

(* Final stronger post condition *)
fun (_ : seq nat) m =>
      if head 0 p_incoming > head 0 p_current
      then loc m = st :-> (e, APromised p_incoming)
      else loc m = st :-> (e, APromised p_current))
\end{lstlisting}

Catching these bugs shows how useful it is to do the proofs in Disel as they
would not have been easily noticed otherwise.
There obviously is the drawback that implementation time is increased as one
needs to prove every single transition. Furthermore, when the inductive
invariant is added, all the transitions need to be show to adhere to it,
thus, requiring more time to implement the proofs.


\section{Future Work}
First steps would definitely be to finish mechanising the left out things
pointed in the previous section. This will help us reach the final stage in the Disel
workflow. After that, it would be possible to try proving the optimisations
in Paxos based on the proof of the `core' protocol. It would also then be possible
to use `Hooks' \cite{9} in Disel to compose the proof with proofs of other
verified components.

There are also a few areas for future work in Disel.
Finding the inductive invariant for the protocol is much harder task than
designing the state transition system. The Disel paper \cite{9} mentioned the prospect
of combining Disel with Ivy \cite{19}, which would offer assistance in finding
the inductive invariant. Another thing, also mentioned in the Disel paper, is
the absence of proving the liveness properties in Disel. Hence, the proof of
Paxos which we implemented also does not account for liveness whereas tools like
IronFleet \cite{15} enable one to also prove liveness.
Finally, another aspect of Paxos which we did not look at was its fault
tolerance properties. There could be ways to encode it in as a part of the
protocol but maybe it might also be possible for Disel to provide an
abstraction which can be used to prove the fault tolerance properties of
any arbitary protocol.
