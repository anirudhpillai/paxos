\chapter{Introduction}

\section{The Problem}
Distributed systems are ubiquitous in the modern world yet
correctly implementing such systems is still very hard. Furthermore, such
systems are composed of various smaller components which in themself are
hard to implement correctly. There has been recent work in developing
frameworks to verify the implementation of the `smaller' sub-components
but there still remains the problem of checking whether these smaller
components, when combined together, achieve the desired goal.

Another fundamental problem in the field of distributed computing is to make
a set of process achieve consensus on something, for examples, the occurrence
of an event or the decision to take some action. The set of distributed
computing protocols which tries to solve this problem are termed as
consensus protocols. One of these protocols is the Paxos consensus protocol
which has numerous variants according to the constraints imposed on the
set of processes.

Disel is a framework for compositional verification of distributed
protocols built on top of the Coq proof assistant. It allows one to verify
the correctness of the implemented components and also to check whether
the verified components function correctly when combined together.

This project involves using Disel to mechanise the proof of the Paxos consensus protocol.
We will also be using the code extraction capabilities of Disel to
write a client application that uses the verified protocol to make set of
distributed processes achieve consensus.

\section{Aims and Goals}
I have highlighted the aims and goals separately. The aims are what I want to
achieve out of undertaking this project and the goals are the things that this
project tries to achieve.

\subsection{Aims}
\begin{enumerate}
\itemsep0em
  \item Learn about distributed computing. I wanted to learn how to reason about
    and implement distributed programs and the algorithms running on top of them.
    Working on verifying a popular distributed system protocol will teach me
    the concepts needed to understand such systems. While actually implementing
    applications using the protocol will teach me how to apply the concepts to
    the real world.
  \item Contribute to open source software. Disel is an open source framework
    and working on that will enrich my open source contributions and improve
    my knowledge of the workflow.
  \item Learn about formal verification. This was based partly on my interest in
    the various courses on logic. Using Coq for verification would enable me
    to apply my theoretical knowledge and use it for
    implementing and verifying a popular distributed system protocol.

\end{enumerate}

\vspace{-5mm}
\subsection{Goals}
\begin{enumerate}
\itemsep0em
  \item Read about and understand the classical Paxos-like consensus algorithms.
  \item Develop state transition systems for the algorithms and identify the invariants that need to be preserved during the operation of the algorithm.
  \item Implement a simulation of the protocols in Python.
  \item Formulate the implemented protocols in Disel by using the developed state-transition systems.
  \item Mechanise the proofs of the identified protocol invariants in Disel/Coq.
  \item Add additional communication channels and prove composite invariants.
  \item Provide an abstract specification of the protocol, usable by third-party clients.
  \item Mechanise a client application of the protocol verified out of the abstract interface.
\end{enumerate}

\vspace{-4mm}
\section{Project Overview}
During the course of the
project we came up with a workflow for using Disel to mechanise proofs of protocols.
This workflow is outlined in detail in section 3.3. The main
stages in the project were as follows:
\begin{itemize}
\itemsep0em
  \item First stage was to read about and understand the various concepts related
    to distributed computing and, more importantly, to understand the workings of
    Paxos-like consensus protocols. Implementing the Python simulation of the
    algorithm was very helpful in understanding the roles of each of the nodes
    in the protocol.

  \item The next stage was to design an adapted protocol that we would prove and
    to design the state transition diagrams of that protocol.
    We also designed the client application that would use the protocol and created
    a Python simulation of it to ensure that the design functioned correctly.

  \item The final stage was actually mechanising the proofs in Disel showing that
    the nodes in the client application correctly implemented the protocol while
    communicating with other nodes and achieving consensus. We first
    encoded the implementation of the client application and the protocol. Once,
    the client application functioned correctly, we moved on to writing proofs
    for it and the encoded protocol.
\end{itemize}

\vspace{-4mm}
\section{Report Overview}
% A brief overview of the rest of the chapters in the report (a guide to
% the reader of the overall structure of the report).
In the following chapter we look at various concepts relating to distributed
computing and understand the two main components of this project, the Paxos
protocol and the Disel framework. Then, with that background information,
we look at how we adapted the design of the Paxos protocol and designed
state transition systems for it. Later,
we move on to actually encoding the protocol in Disel and creating a client
application that uses the verified protocol.
Finally, we evaluate the results of the project, the
experience of using Disel and look at areas for future
development.
