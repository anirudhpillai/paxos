\chapter{Client Application}
As outlined in chapter 2, our approach to using Disel involved first coding
the protocol and the client application, and then going on write the proofs.
Having the client application working before writing the proofs gave us
confidence that the design of our adapted protocol worked and could be used
to achieve consensus.

In this chapter we look at how we implemented a simple client application
that uses the proof of our adapted protocol to create an implementation of nodes
that achieve consensus on a value. We first look at how the client application was
designed and coded in Disel then we look into how we used Disel's \texttt{shims}
runtime to extract the OCaml code for the client. Finally, we will look at how
we verfied the client application.

\section{Modelling}
%% TODO: give a textual description with a lot of intuition about what kind of client
%   we are interested in and what properties it can observe that are guaranteed by the consensus.

The main property that we want to observe from the client is the acceptors achieving
consensus on a proposal. This meant we needed to be able to see that a majority of
acceptors accepting a protocol and that all of the acceptors in the majority
accept the same protocol.

Furthermore, we needed the client application to follow the same state transition
system we designed for our adapted protocol. Thus, the correct functioning of the
client will give us confidence that our adapted protocol can be proved. This also
enables us to catch flaws in our design of the adapted protocol early on and helps
us detect things like unnecessary states early on in the process, which makes the
proving the protocol easier in the later stages.

So our client was simple in that we wanted to initialise two proposers and three
acceptors and then see the acceptors achieve consensus. Each proposal that is intialised
will only try once to achieve consensus using the proposal number that it is initialised
with. If it receives a nack in the process, then it stops and does not retry to
achieve consensus with a higher proposal number. As explained in the previous
chapter, we choose this 'one shot' process for the proposer in order to focus on
just on the part where consensus is achieved, where the proposer accumulates
enough promises and then sends out an accept request which then may be accepted
by each of the acceptors.

\section{Implementation}
Having decided on the design of the client, we needed to write the runnable implementation of a
proposer and an acceptor which each of these nodes can run as programs. Here we
will only look at the implementation of the proposer, the implementation of
the acceptor follows from that and can be found in the \texttt{PaxosAcceptor.v} file.

As a proposer starts off in the \texttt{PInit} state, the runnable implementation
of a proposer needs to take in a proposal as a parameter which it will use to
initilise the proposer with. Below is the main function for the proposer.
It first sends out the prepare requests and then starts receiving responses
from the acceptors. \texttt{check\_promises} function checks that none of the
responses contain a nack request. If no nacks were received then the proposer
sends accept requests to all the acceptors by choosing the value from the
highest numbered proposal.

\begin{lstlisting}
Program Definition proposer_round (psal: proposal):
  {(e : nat)}, DHT [p, W]
  (fun i => loc i = st :-> (e, PInit psal),
   fun res m => loc m = st :-> (e.+1, PAbort))
  :=
  Do (e <-- read_round;
      send_prepare_req_loop e psal;;
      recv_promises <-- receive_prepare_resp_loop e;
      check <-- check_promises recv_promises;
      if check
      then send_accept_reqs e (choose_highest_numbered_proposal psal recv_promises)
      else send_accept_reqs e [:: 0; 0]).
     (* If check fails then send an acc_req for (0, 0) which will never be
        accepted by any acceptor *)
\end{lstlisting}

Although, if a nack was recieved, the proposal still sends
accept requests with the proposal $\langle 0, 0 \rangle$. This proposal will
never be accepted by any acceptor as its proposal number is not greater than 0.
We still need to send these accept requests as both branches of a \texttt{if}
statement need to have the same type.

One can also see the distributed Hoare types and the pre and post conditions
defined above. Once the proposer finished the round, it ends up in the \texttt{PAbort}
state with its round number incremented. A proposer will only have one go at achieving
consensus and will not try again if it fails. This corresponds to the decision we
made while designing the adapted protocol.

\section{Extraction}
Disel programs can be extracted into their corresponding OCaml definitions.
The extracted code contains modules to that define the various node states
and transitions. This extracted code can then be used by a shim to create a
client application.

In order for the extraction to work, we need to assign a program to run for
each node participating in the protocol. Additionnaly, each node needs to
be given an initial state that satisifed all the imposed invariants.

The design of our client application was very simple. We aimed to initialise
two proposers, \texttt{proposer1} with proposal $\langle 1, 1\rangle$ and
\texttt{proposer2} with proposal $\langle 2, 2\rangle$ along with three different
acceptors.

Before running the extraction, we need the \texttt{SimplePaxosApp.v} file
which defines the code to instantiate the nodes.
Our client implementation instantiates two proposers and three acceptors.
Each proposer is instantiated with a unique proposol which is required in the
\texttt{PInit} state.

\begin{lstlisting}
(* [Run] Runnable proposer code *)
Program Definition run_proposer p psal:
  DHT [p, _] (
    fun i => network_rely W p init_state i,
    fun _ m => exists (r : nat),
    getLocal p (getStatelet m l) = st :-> (r, PInit psal))
  := Do (with_inv (PaxosInductiveInv.ii _ _ _) (proposer p psal)).
...

(* [Run] Runnable nodes *)
Program Definition run_proposer1 := run_proposer p1 psal_1.

...
(* [Run] Final programs to run with actual arguments supplied *)
Definition p_runner1 (u : unit) := run_proposer1 [:: 1; 1].
\end{lstlisting}

After extracting the Coq code, we then wrote a shim file (\texttt{PaxosMain.ml})
that parses the arguement supplied to it and instantiates a program specified
for the given node. Below is the main function from the shim file.

\begin{lstlisting}
let main () =
  parse_args (List.tl (Array.to_list Sys.argv));
  match !mode, !me with
  | Some mode, Some me ->
    begin
      Shim.setup { nodes = !nodes; me = me; st = SimplePaxosApp.init_state };
      match mode with
      | Acceptor ->
        begin match int_of_nat me with
        | 3 -> SimplePaxosApp.a_runner1 ()
        | 4 -> SimplePaxosApp.a_runner2 ()
        | 5 -> SimplePaxosApp.a_runner3 ()
        | n -> usage ("unknown acceptor name " ^ string_of_int n)
        end
      | Proposer ->
        begin match int_of_nat me with
        | 1 ->
          begin
            try
              SimplePaxosApp.p_runner1 ()
            with _ -> print_endline "A acceptor closed its connection, proposer exiting."
          end
        | 2 ->
          begin
            try
              SimplePaxosApp.p_runner2 ()
            with _ -> print_endline "A acceptor closed its connection, proposer exiting."
          end
        | n -> usage ("unknown proposer name " ^ string_of_int n)
        end
    end
  | _, _ -> usage "-mode and -me must be given"
\end{lstlisting}

Finally, we had to write a shell script to call the shim file with the separate
arguements to instantiate all the different nodes as different processes.
%% TODO: Add logs showing consensus being achieved.
